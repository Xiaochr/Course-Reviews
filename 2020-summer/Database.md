# 数据库

## 数据库基本介绍

元数据（metadata）描述数据库中数据的属性和特点的数据，如数据的定义、数据结构以及规则、约束等。

数据是信息的符号表示或载体，信息是数据的内涵，是对数据的语义解释。

### 数据库管理系统

- 功能：
    - 允许用户用一种叫做**数据定义语言**(data Definition language: DDL) 的专用语言建立新的数据库和定义模式
    - 使用户能够用适当的语言（查询语言或**数据操纵语言**Data Manipulation Language: DML）查询和更新数据
    - 支持存储大量的数据，经很长时间后仍能正确访问，并保证其安全性。
    - 能够控制多用户的同时并发访问。

- 数据库
    - 物理（主体）
    - 描述（元数据）

- 人员
    - 数据库管理员（DBA）、系统分析员、应用程序员、最终用户

- 数据模型
    - 概念模型
        - 实体联系模型、面向对象模型
    - 逻辑模型
        - 关系、网络、层次
    - 物理模型
        - RAID

### 数据库应用开发

- 文件系统不具备 DBMS 应具备的很多功能

- 适合用数据库技术实现的信息系统是数据密集型应用系统（data intensive application）

- 数据库应用系统的开发方法
    - 系统开发生命周期法（system development life cycle, SDLC）
        - 七步骤：项目规划、需求分析、概念设计、逻辑设计、物理设计、实现和维护。
    - 快速应用开发方法（rapid application development, RAD）

## ER模型

### 基本ER数据模型
- 实体
    - 实体单线矩形框，弱实体双线矩形框
    - 弱实体的属性中不存在主键，其主键需要其依赖的实体的主键和其本身的某些属性共同组成
    - 强实体与弱实体之间是 1对多 联系
- 联系
    - 二元联系，一元联系（递归联系），三元联系（菱形框）
    - 联系的属性，虚线+矩形框
- 属性
    - 简单、复合、单值、多值、派生
    - 候选键$\{PK\}$, $\{PPK\}$：主键、替补键
- 结构约束
    - min2指实体集E1中实体的最小参与次数
    - 参与约束（min）：全参与、部分参与。$min1=0$则E2部分参与，$min1>0$则E2完全参与。
    - 基数约束（max）：一对一、一对多、多对一、多对多

### 增强ER模型（EER）

- 特殊化（specialization）
    - 父类子类
    - 参与约束：全特殊化，强制（mandatory）；部分特殊化，任选（optional）
    - 不相交约束：重叠特殊化（And），超类中的实体可以同时属于多个同层次子类；不相交特殊化（Or）
    - $\{Optional, Or\}$

- 概括（generalization）
    - 是特殊化的逆过程

- 聚集（aggregation）

## 关系数据模型

- 关系的特点
    - 分量不可分，行相异，列同质

- OrderDetail(orderNo, pCode, qty, discount)

- 键
    - 候选键
        - 主属性：包含在任一个候选键中的属性；非主属性
    - 主键
    - 外键
        - 不是本关系的候选键，是引用其他关系的键
    - 超键

- 约束
    - 域完整性约束
    - 实体完整性约束
        - 每个关系都要有不为空的主键
    - 参照完整性约束（外键约束）
    - 其他一般约束

### 关系代数

- 基本操作
    - 选择（selection） $\sigma$
    - 投影（projection） $\pi$
    - 并（union）
    - 笛卡尔积（cross-product） $\times$
    - 集合差（set-difference）
    - 其他推导出的：交（intersection）、连接（join）、重命名（renaming）、除（division）
        - 自然连接：属性名相同的属性的取值相等，结果关系将属性名相同的列只保留一个
        - 外连接：左外连接、右、全
        - 重命名，自连接 $\rho$
        - 除：$r \div s = \pi_x(r) - \pi_x((\pi_x(r)\times s) - r)$，其中$x = attr(r) - attr(s)$

## ER模型转换为关系模型

- 转换过程
    - 一个实体转换为一个关系模式
    - 联系的转换
        - 一个多对多二元联系转换为一个关系模式
        - 一对一：全参与、部分参与
        - 一对多的属性和一端实体的主键放入多端实体的关系中

- EER模型的转换

## 数据库的规范化理论

- 更新异常问题
    - 存储冗余
    - 插入异常
    - 删除异常
    - 修改异常

- 函数依赖
    - 检验 $A\rightarrow B$ 是否成立：若A相同则B相同。
    - 一一对应 $A \leftrightarrow B$
    - 非平凡函数依赖：B不是A的任一个子集
    - 完全函数依赖：B不依赖于A的任何非空真子集
    - 传递函数依赖

- Armstrong公理
    - 自反律
    - 增广律
    - 传递律
    - 其他推论：合并律、分解律、伪传递律

- **求所有的候选键**

- 一个不包含在任何函数依赖中的属性，会出现在所有候选键中；一个只出现在函数依赖的右边的属性，不会出现在任何候选键中

- 闭包
    - F的闭包是是F所逻辑蕴涵的所有的函数依赖的集合
    - **计算属性集A关于F的闭包**

- **最小覆盖**
    - 满足三个条件
    - 步骤：分别检查三个条件

### 范式

- 1NF
    - 分量不可分

- 2NF
    - 属于1NF，如果每个非主属性都完全函数依赖于关系的候选键，则关系模式R属于2NF

- 3NF
    - 属于1NF，如果不存在任何非主属性对候选键的传递函数依赖，则关系模式R属于3NF
    - 若3NF则必2NF

- BCNF
    - 属于1NF，对于每个非平凡的函数依赖$A\rightarrow B$, 若其决定因素都是超键，则关系模式R属于BCNF
    - 若BCNF则必3NF，反之不成立

- 多值依赖
    - 假设A和B是关系模式R（U）的两个属性组，若对于R的任一个关系r，A的每一个取值对应B的一组取值，而这组取值与R的其他属性C (C=U-AB)的取值是没有关系的，则称多值依赖 $A \rightarrow \rightarrow B$
    - 检查方法：公式
    - 性质：互补律、复制律

- 4NF
    - 属于1NF，若其中存在的每一个多值依赖$A\rightarrow \rightarrow B$都满足以下两个条件之一，则关系模式R属于4NF
        - 平凡多值依赖
        - A是超键
    - 若4NF必BCNF

### **规范化**：分解

- 无损连接分解
    - 充要条件：$F^+$包含函数依赖 $U_1 \land U_2 \rightarrow U_1$或$U_2$
    - 必须保持

- 保持依赖分解
    - 判断是否保持依赖算法
    - 最好保持


- 符合BCNF的无损分解
    - 算法

- 符合3NF的保持依赖的无损分解
    - 算法

- 关系模式的合并与调整
    - 反规范化
    - 横向分割
    - 纵向分割

## SQL


## 并发控制

### 事务

- 事务（transaction）是DBMS的一个程序执行单元，通常由一组存取数据库的操作组成。

- 事务的性质 ACID
    - 原子性 atomicity
        - 构成事务的操作要么全执行要么全不执行
    - 一致性 consistency
        - 从一个一致状态转移到另一个一致状态
    - 隔离性 isolation
        - 事务的执行不受与其同时执行的事务的影响，同时发生的结果应与某一串行发生的结果相同
    - 持久性 durability
        - 对数据库的影响是持久的

- Basic operations
    - read
    - write
    - commit
    - rollback

### 调度

- 串行调度

- 并发调度
    - 可串行化调度

- 并发调度异常
    - 丢失更新异常（写写冲突）
    - 读脏数据异常（写读异常）
        - rollback：不可恢复调度，级联撤销（看是否commit）
    - 不能重复读异常（读写冲突）
    - 出现幻象异常

- 封锁（lock）
    - 共享锁（S锁）
        - 通常是对要读的对象加
    - 排它锁（X锁）
        - 通常是对要写的对象加

- 严格的两段锁协议
    - 如果一个事务T需要读，则应先获得对象的S锁；若需要写，则应先获得对象的X锁。
    - T申请到的所有锁一直拥有到T结束才释放。

- 两段锁协议
    - 如果一个事务T需要读，则应先获得对象的S锁；若需要写，则应先获得对象的X锁。
    - T释放锁之后就不能再获得新锁，允许提前释放。

- 封锁粒度越小，并发度越高，管理的代价也更高。

- 隔离级别
    - level3：serializable，可串行化
    - level2：repeatable read，只允许读已提交的数据对象，两次读之间其他事务不能对其进行修改
        - 避免不能重复读异常，不能保证可串行化（幻象）
    - level1：read committed，只能读取已提交数据
        - 避免读脏数据异常，不能避免不可重复读异常
    - level0：允许读取未提交数据
        - 避免丢失更新异常，不能避免读脏数据异常






---

[Back to top](#数据库)
